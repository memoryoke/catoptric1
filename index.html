<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Dynamic Quadrant Video Processor</title>

<style>
body {
  margin: 0;
  background: #111;
  color: #eee;
  font-family: sans-serif;
  display: flex;
  justify-content: center;
}

#app {
  width: 100vw;
  max-width: 100vmin;
  display: flex;
  flex-direction: column;
  align-items: center;
}

canvas {
  width: 100%;
  aspect-ratio: 1 / 1;
  background: #000;
  image-rendering: pixelated;
  display: block;
}

#controls {
  width: 100%;
  background: #1a1a1a;
  padding: 0.75rem;
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 0.6rem;
  box-sizing: border-box;
}

.button {
  background: #444;
  border: 1px solid #555;
  color: #fff;
  padding: 0.6rem;
  border-radius: 6px;
  font-size: 0.85rem;
  cursor: pointer;
  text-align: center;
}

.button:active { background: #555; }
.active-effect { background: #007bff !important; border-color: #00a2ff; }

.slider-wrap {
  grid-column: span 4;
  display: flex;
  align-items: center;
  gap: 0.6rem;
  font-size: 0.8rem;
}

.slider-wrap span { width: 80px; text-align: right; }
input[type="range"] { flex: 1; }
.span-2 { grid-column: span 2; }

#gridSizeDisplay {
  grid-column: span 4;
  text-align: center;
  font-family: monospace;
  background: #333;
  padding: 0.4rem;
  border-radius: 4px;
}

#videoFeed { display: none; }
</style>
</head>
<body>

<div id="app">
  <canvas id="canvas"></canvas>
  <div id="controls">
    <button id="startWebcamButton" class="button span-2">Start Camera</button>
    <button id="freezeButton" class="button span-2">Freeze Frame</button>
    
    <label class="button span-4">
      <input id="autoGridToggle" type="checkbox"> Enable Auto-Grid (Brightness Based)
    </label>

    <div id="gridSizeDisplay">Grid: 10×10</div>
    <div class="slider-wrap">
      <span>Grid Size</span>
      <input id="gridSlider" type="range" min="1" max="40" value="10">
    </div>

    <div class="slider-wrap">
      <span>Cell Scale</span>
      <input id="cellScaleSlider" type="range" min="0.1" max="2.0" step="0.05" value="1">
    </div>

    <div class="slider-wrap"><span>Brightness</span><input id="brightnessSlider" type="range" min="50" max="150" value="100"></div>
    <div class="slider-wrap"><span>Contrast</span><input id="contrastSlider" type="range" min="50" max="150" value="100"></div>
    <div class="slider-wrap"><span>Saturation</span><input id="saturationSlider" type="range" min="0" max="200" value="100"></div>

    <button id="effectA1" class="button effect-button">Agnes</button>
    <button id="effectA2" class="button effect-button">Bridget</button>
    <button id="effectB1" class="button effect-button">Chuck</button>
    <button id="effectB2" class="button effect-button">Donald</button>

    <button id="clearEffectButton" class="button span-2">Original</button>
    <button id="downloadButton" class="button span-2">Save Image</button>
  </div>
</div>

<video id="videoFeed" playsinline autoplay muted></video>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const video = document.getElementById('videoFeed');

// Offscreen canvas stores the processed "source" frame
const offscreenCanvas = document.createElement('canvas');
const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });

let stream = null;
let frozen = false;
let cols = 10, rows = 10;
let autoGrid = false;
let currentQuadrantEffect = 'A1';
let cellScale = 1.0;
let brightness = 100, contrast = 100, saturation = 100;

// Pro-tip: Smoothing buffer for AutoGrid
let targetGridSize = 10;
let lastUpdate = 0;

/* ---------- UI HANDLERS ---------- */

const gridSlider = document.getElementById('gridSlider');
const gridDisplay = document.getElementById('gridSizeDisplay');
const autoGridToggle = document.getElementById('autoGridToggle');

gridSlider.oninput = () => {
  if (!autoGrid) {
    cols = rows = parseInt(gridSlider.value);
    updateGridDisplay();
  }
};

autoGridToggle.onchange = () => autoGrid = autoGridToggle.checked;
document.getElementById('cellScaleSlider').oninput = (e) => cellScale = parseFloat(e.target.value);
document.getElementById('brightnessSlider').oninput = (e) => brightness = e.target.value;
document.getElementById('contrastSlider').oninput = (e) => contrast = e.target.value;
document.getElementById('saturationSlider').oninput = (e) => saturation = e.target.value;

function updateGridDisplay() {
  gridDisplay.textContent = `Grid: ${cols}×${rows}`;
}

function setEffect(e) {
  currentQuadrantEffect = e;
  document.querySelectorAll('.effect-button').forEach(b => {
    b.classList.toggle('active-effect', b.id === `effect${e}`);
  });
}

['A1','A2','B1','B2'].forEach(e =>
  document.getElementById(`effect${e}`).onclick = () => setEffect(e)
);

document.getElementById('clearEffectButton').onclick = () => setEffect(null);

document.getElementById('startWebcamButton').onclick = async () => {
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: true });
    video.srcObject = stream;
    video.onloadedmetadata = () => {
      const size = Math.min(video.videoWidth, video.videoHeight);
      canvas.width = canvas.height = size;
      offscreenCanvas.width = offscreenCanvas.height = size;
      loop();
    };
  } catch (err) { console.error("Camera error:", err); }
};

document.getElementById('freezeButton').onclick = () => {
  frozen = !frozen;
  document.getElementById('freezeButton').textContent = frozen ? "Unfreeze" : "Freeze Frame";
};

/* ---------- CORE LOGIC ---------- */

function loop() {
  if (!stream) return;

  if (!frozen) {
    // Apply image filters to the offscreen buffer
    offscreenCtx.filter = `brightness(${brightness}%) contrast(${contrast}%) saturate(${saturation}%)`;
    offscreenCtx.drawImage(video, (video.videoWidth - canvas.width)/2, (video.videoHeight - canvas.height)/2, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);
  }

  if (autoGrid) {
    handleAutoGrid();
  }

  if (currentQuadrantEffect) {
    renderKaleidoscope(currentQuadrantEffect);
  } else {
    ctx.drawImage(offscreenCanvas, 0, 0);
  }

  requestAnimationFrame(loop);
}

function handleAutoGrid() {
  // Pro-Tip: Don't calculate every single frame to save CPU
  const now = Date.now();
  if (now - lastUpdate < 100) return; 
  lastUpdate = now;

  const data = offscreenCtx.getImageData(0, 0, offscreenCanvas.width, offscreenCanvas.height).data;
  let brightnessSum = 0;
  for (let i = 0; i < data.length; i += 40) { // Sample every 10th pixel
    brightnessSum += (data[i] + data[i+1] + data[i+2]) / 3;
  }
  const avg = brightnessSum / (data.length / 40);
  
  // Map brightness 0-255 to grid 2-40
  const newSize = Math.floor(2 + (avg / 255) * 38);
  
  // Smooth transition: only update if change is significant
  if (Math.abs(newSize - cols) > 1) {
    cols = rows = newSize;
    updateGridDisplay();
  }
}

function renderKaleidoscope(target) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.imageSmoothingEnabled = false;

  const baseW = canvas.width / cols;
  const baseH = canvas.height / rows;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const centerX = c * baseW + baseW / 2;
      const centerY = r * baseH + baseH / 2;

      // The size we draw, affected by cellScale
      const drawW = baseW * cellScale;
      const drawH = baseH * cellScale;
      const qW = drawW / 2;
      const qH = drawH / 2;

      // Source Sampling Coordinates (The "Quadrant" logic)
      let sx = c * (offscreenCanvas.width / cols);
      let sy = r * (offscreenCanvas.height / rows);
      const sSizeW = (offscreenCanvas.width / cols) / 2;
      const sSizeH = (offscreenCanvas.height / rows) / 2;

      if (target === 'A2') sx += sSizeW;
      if (target === 'B1') sy += sSizeH;
      if (target === 'B2') { sx += sSizeW; sy += sSizeH; }

      // Draw the 4 mirrored quadrants
      const transforms = [
        { sx: 1, sy: 1 },  { sx: -1, sy: 1 },
        { sx: 1, sy: -1 }, { sx: -1, sy: -1 }
      ];

      transforms.forEach(t => {
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.scale(t.sx, t.sy);
        // Draw image from offscreen source
        ctx.drawImage(offscreenCanvas, sx, sy, sSizeW, sSizeH, 0, 0, qW, qH);
        ctx.restore();
      });
    }
  }
}

document.getElementById('downloadButton').onclick = () => {
  const a = document.createElement('a');
  a.download = 'kaleidoscope-export.png';
  a.href = canvas.toDataURL('image/png');
  a.click();
};

// Init
setEffect('A1');
updateGridDisplay();
</script>
</body>
</html>
