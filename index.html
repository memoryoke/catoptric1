<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Dynamic Quadrant Video Processor</title>

<style>
body {
  margin: 0;
  background: #111;
  color: #eee;
  font-family: sans-serif;
  display: flex;
  justify-content: center;
}

#app {
  width: 100vw;
  max-width: 100vmin;
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* -------- CANVAS -------- */

canvas {
  width: 100%;
  aspect-ratio: 1 / 1;
  background: #333;
  image-rendering: pixelated;
  display: block;
}

/* -------- CONTROLS -------- */

#controls {
  width: 100%;
  background: #1a1a1a;
  padding: 0.75rem;
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 0.6rem;
  box-sizing: border-box;
}

.button {
  background: #444;
  border: 1px solid #555;
  color: #fff;
  padding: 0.6rem;
  border-radius: 6px;
  font-size: 0.85rem;
  cursor: pointer;
}

.button.active-effect {
  background: #6a6a6a;
}

.slider-wrap {
  grid-column: span 4;
  display: flex;
  align-items: center;
  gap: 0.6rem;
  font-size: 0.8rem;
}

.slider-wrap span {
  width: 80px;
  text-align: right;
}

input[type="range"] {
  flex: 1;
}

.span-2 { grid-column: span 2; }
.span-4 { grid-column: span 4; }

#gridSizeDisplay {
  grid-column: span 4;
  text-align: center;
  font-family: monospace;
  background: #333;
  padding: 0.4rem;
  border-radius: 4px;
}

#videoFeed { display: none; }
</style>
</head>

<body>

<div id="app">

  <canvas id="canvas"></canvas>

  <div id="controls">

    <!-- CAMERA -->
    <button id="startWebcamButton" class="button span-2">Start</button>
    <button id="stopWebcamButton" class="button span-2">Stop</button>
    <button id="freezeButton" class="button span-2">Freeze</button>
    <label class="button span-2">
      <input id="autoGridToggle" type="checkbox"> Auto grid
    </label>

    <!-- GRID -->
    <div id="gridSizeDisplay">Grid: 10×10</div>
    <div class="slider-wrap">
      <span>Grid</span>
      <input id="gridSlider" type="range" min="1" max="30" value="10">
    </div>

    <!-- CELL SCALE -->
    <div class="slider-wrap">
      <span>Cell size</span>
      <input id="cellScaleSlider" type="range" min="0.25" max="3" step="0.05" value="1">
    </div>

    <!-- IMAGE CONTROLS -->
    <div class="slider-wrap">
      <span>Brightness</span>
      <input id="brightnessSlider" type="range" min="50" max="150" value="100">
    </div>

    <div class="slider-wrap">
      <span>Contrast</span>
      <input id="contrastSlider" type="range" min="50" max="150" value="100">
    </div>

    <div class="slider-wrap">
      <span>Saturation</span>
      <input id="saturationSlider" type="range" min="0" max="200" value="100">
    </div>

    <!-- MODES -->
    <button id="effectA1" class="button effect-button">Agnes</button>
    <button id="effectA2" class="button effect-button">Bridget</button>
    <button id="effectB1" class="button effect-button">Chuck</button>
    <button id="effectB2" class="button effect-button">Donald</button>

    <!-- OUTPUT -->
    <button id="clearEffectButton" class="button span-2">Original</button>
    <button id="downloadButton" class="button span-2">download image</button>

  </div>
</div>

<video id="videoFeed" playsinline autoplay muted></video>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently:true });
const video = document.getElementById('videoFeed');

const offscreenCanvas = document.createElement('canvas');
const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently:true });

const tempCanvas = document.createElement('canvas');
const tempCtx = tempCanvas.getContext('2d', { willReadFrequently:true });

let stream = null;
let frozen = false;
let frozenFrame = null;

let cols = 10, rows = 10;
let autoGrid = false;
let currentQuadrantEffect = 'A1';

let cellScale = 1;
let brightness = 100;
let contrast = 100;
let saturation = 100;

/* ---------- UI ---------- */

const gridSlider = document.getElementById('gridSlider');
const gridDisplay = document.getElementById('gridSizeDisplay');
const autoGridToggle = document.getElementById('autoGridToggle');

const cellScaleSlider = document.getElementById('cellScaleSlider');
const brightnessSlider = document.getElementById('brightnessSlider');
const contrastSlider = document.getElementById('contrastSlider');
const saturationSlider = document.getElementById('saturationSlider');

gridSlider.oninput = () => {
  if (!autoGrid) {
    cols = rows = parseInt(gridSlider.value);
    updateGrid();
  }
};

autoGridToggle.onchange = () => autoGrid = autoGridToggle.checked;
cellScaleSlider.oninput = () => cellScale = parseFloat(cellScaleSlider.value);
brightnessSlider.oninput = () => brightness = brightnessSlider.value;
contrastSlider.oninput = () => contrast = contrastSlider.value;
saturationSlider.oninput = () => saturation = saturationSlider.value;

function updateGrid() {
  gridDisplay.textContent = `Grid: ${cols}×${rows}`;
}

/* ---------- EFFECTS ---------- */

function setEffect(e) {
  currentQuadrantEffect = e;
  document.querySelectorAll('.effect-button').forEach(b => {
    b.classList.toggle('active-effect', b.id === `effect${e}`);
  });
}

['A1','A2','B1','B2'].forEach(e =>
  document.getElementById(`effect${e}`).onclick = () => setEffect(e)
);

document.getElementById('clearEffectButton').onclick = () => setEffect(null);

/* ---------- CAMERA ---------- */

document.getElementById('startWebcamButton').onclick = async () => {
  stream = await navigator.mediaDevices.getUserMedia({ video:true });
  video.srcObject = stream;
  await video.play();

  const size = Math.min(video.videoWidth, video.videoHeight);
  canvas.width = canvas.height = size;
  offscreenCanvas.width = offscreenCanvas.height = size;

  loop();
};

document.getElementById('stopWebcamButton').onclick = () => {
  stream?.getTracks().forEach(t => t.stop());
  stream = null;
};

document.getElementById('freezeButton').onclick = () => {
  frozen = !frozen;
  if (frozen) {
    frozenFrame = offscreenCtx.getImageData(0,0,canvas.width,canvas.height);
  }
};

/* ---------- MAIN LOOP ---------- */

function loop() {
  if (!stream) return;

  if (!frozen) {
    offscreenCtx.filter =
      `brightness(${brightness}%) contrast(${contrast}%) saturate(${saturation}%)`;
    offscreenCtx.drawImage(video,0,0,canvas.width,canvas.height);
    frozenFrame = offscreenCtx.getImageData(0,0,canvas.width,canvas.height);
  }

  if (autoGrid) {
    let sum = 0;
    const d = frozenFrame.data;
    for (let i=0;i<d.length;i+=4)
      sum += 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
    cols = rows = Math.max(1, Math.min(30,
      Math.round((sum/(d.length/4))/255 * 30)
    ));
    updateGrid();
  }

  if (currentQuadrantEffect)
    processQuadrant(currentQuadrantEffect,false,frozenFrame);
  else
    ctx.putImageData(frozenFrame,0,0);

  requestAnimationFrame(loop);
}

/* ---------- processQuadrant (UNCHANGED) ---------- */

function processQuadrant(target,setState,sourceImageData){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.imageSmoothingEnabled=false;
  tempCtx.imageSmoothingEnabled=false;

  const sw=sourceImageData.width;
  const sh=sourceImageData.height;
  const data=sourceImageData.data;

  const baseW=canvas.width/cols;
  const baseH=canvas.height/rows;

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const x=Math.floor(c*baseW);
      const y=Math.floor(r*baseH);
      const w=Math.floor(baseW*cellScale);
      const h=Math.floor(baseH*cellScale);
      const qW=Math.floor(w/2);
      const qH=Math.floor(h/2);
      if(qW<=0||qH<=0) continue;

      let sx=x, sy=y;
      if(target==='A2') sx+=qW;
      if(target==='B1') sy+=qH;
      if(target==='B2'){sx+=qW;sy+=qH;}

      sx=Math.min(sw-qW,Math.max(0,sx));
      sy=Math.min(sh-qH,Math.max(0,sy));

      tempCanvas.width=qW;
      tempCanvas.height=qH;
      const img=tempCtx.createImageData(qW,qH);

      for(let yy=0;yy<qH;yy++)
        for(let xx=0;xx<qW;xx++){
          const si=((sy+yy)*sw+(sx+xx))*4;
          const di=(yy*qW+xx)*4;
          img.data.set(data.slice(si,si+4),di);
        }

      tempCtx.putImageData(img,0,0);

      [
        {dx:x,dy:y,sx:1,sy:1},
        {dx:x+w,dy:y,sx:-1,sy:1},
        {dx:x,dy:y+h,sx:1,sy:-1},
        {dx:x+w,dy:y+h,sx:-1,sy:-1}
      ].forEach(o=>{
        ctx.save();
        ctx.translate(o.dx,o.dy);
        ctx.scale(o.sx,o.sy);
        ctx.drawImage(tempCanvas,0,0,qW,qH,0,0,w/2,h/2);
        ctx.restore();
      });
    }
  }
}

/* ---------- DOWNLOAD ---------- */

document.getElementById('downloadButton').onclick = () => {
  const a=document.createElement('a');
  a.download='image.png';
  a.href=canvas.toDataURL();
  a.click();
};

/* ---------- DEFAULTS ---------- */

setEffect('A1');
updateGrid();
</script>

</body>
</html>
