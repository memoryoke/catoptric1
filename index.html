<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Dynamic Quadrant Video Processor</title>

<style>
body {
  margin: 0;
  background: #111;
  color: #eee;
  font-family: sans-serif;
  display: flex;
  justify-content: center;
}

#app {
  width: 100vw;
  max-width: 100vmin;
  display: flex;
  flex-direction: column;
  align-items: center;
}

canvas {
  width: 100%;
  aspect-ratio: 1 / 1;
  background: #333;
  image-rendering: pixelated;
  display: block;
}

#controls {
  width: 100%;
  background: #1a1a1a;
  padding: 0.75rem;
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 0.6rem;
  box-sizing: border-box;
}

.button {
  background: #444;
  border: 1px solid #555;
  color: #fff;
  padding: 0.6rem;
  border-radius: 6px;
  font-size: 0.85rem;
  cursor: pointer;
  text-align: center;
}

.button.active-effect {
  background: #6a6a6a;
  border-color: #fff;
}

.slider-wrap {
  grid-column: span 4;
  display: flex;
  align-items: center;
  gap: 0.6rem;
  font-size: 0.8rem;
}

.slider-wrap span {
  width: 80px;
  text-align: right;
}

input[type="range"] {
  flex: 1;
}

.span-2 { grid-column: span 2; }
.span-4 { grid-column: span 4; }

#gridSizeDisplay {
  grid-column: span 4;
  text-align: center;
  font-family: monospace;
  background: #333;
  padding: 0.4rem;
  border-radius: 4px;
}

#videoFeed { display: none; }
</style>
</head>

<body>

<div id="app">
  <canvas id="canvas"></canvas>

  <div id="controls">
    <button id="startWebcamButton" class="button span-2">Start</button>
    <button id="stopWebcamButton" class="button span-2">Stop</button>
    <button id="freezeButton" class="button span-2">Freeze</button>
    <label class="button span-2">
      <input id="autoGridToggle" type="checkbox"> Auto grid
    </label>

    <div id="gridSizeDisplay">Grid: 10×10</div>
    <div class="slider-wrap">
      <span>Grid Size</span>
      <input id="gridSlider" type="range" min="1" max="40" value="10">
    </div>

    <div class="slider-wrap">
      <span>Brightness</span>
      <input id="brightnessSlider" type="range" min="50" max="150" value="100">
    </div>

    <div class="slider-wrap">
      <span>Contrast</span>
      <input id="contrastSlider" type="range" min="50" max="150" value="100">
    </div>

    <div class="slider-wrap">
      <span>Saturation</span>
      <input id="saturationSlider" type="range" min="0" max="200" value="100">
    </div>

    <button id="effectA1" class="button effect-button">Agnes</button>
    <button id="effectA2" class="button effect-button">Bridget</button>
    <button id="effectB1" class="button effect-button">Chuck</button>
    <button id="effectB2" class="button effect-button">Donald</button>

    <button id="clearEffectButton" class="button span-2">Original</button>
    <button id="downloadButton" class="button span-2">Download Image</button>
  </div>
</div>

<video id="videoFeed" playsinline autoplay muted></video>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const video = document.getElementById('videoFeed');

// Offscreen buffer for processing filters
const offscreenCanvas = document.createElement('canvas');
const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });

let stream = null;
let frozen = false;
let gridSize = 10;
let autoGrid = false;
let currentQuadrantEffect = 'A1';
let brightness = 100, contrast = 100, saturation = 100;
let lastAutoUpdate = 0;

/* ---------- UI ---------- */

const gridSlider = document.getElementById('gridSlider');
const gridDisplay = document.getElementById('gridSizeDisplay');
const autoGridToggle = document.getElementById('autoGridToggle');

gridSlider.oninput = () => {
  if (!autoGrid) {
    gridSize = parseInt(gridSlider.value);
    updateGridDisplay();
  }
};

autoGridToggle.onchange = () => autoGrid = autoGridToggle.checked;
document.getElementById('brightnessSlider').oninput = (e) => brightness = e.target.value;
document.getElementById('contrastSlider').oninput = (e) => contrast = e.target.value;
document.getElementById('saturationSlider').oninput = (e) => saturation = e.target.value;

function updateGridDisplay() {
  gridDisplay.textContent = `Grid: ${gridSize}×${gridSize}`;
}

function setEffect(e) {
  currentQuadrantEffect = e;
  document.querySelectorAll('.effect-button').forEach(b => {
    b.classList.toggle('active-effect', b.id === `effect${e}`);
  });
}

['A1','A2','B1','B2'].forEach(e =>
  document.getElementById(`effect${e}`).onclick = () => setEffect(e)
);

document.getElementById('clearEffectButton').onclick = () => setEffect(null);

/* ---------- CAMERA (Restored Logic) ---------- */

document.getElementById('startWebcamButton').onclick = async () => {
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: true });
    video.srcObject = stream;
    await video.play();

    // Use the actual video dimensions to set up canvas
    const size = Math.min(video.videoWidth, video.videoHeight);
    canvas.width = canvas.height = size;
    offscreenCanvas.width = offscreenCanvas.height = size;

    loop();
  } catch (err) {
    console.error("Camera error: ", err);
    alert("Could not start camera. Please ensure you are using HTTPS or localhost.");
  }
};

document.getElementById('stopWebcamButton').onclick = () => {
  stream?.getTracks().forEach(t => t.stop());
  stream = null;
};

document.getElementById('freezeButton').onclick = () => {
  frozen = !frozen;
};

/* ---------- MAIN LOOP ---------- */

function loop() {
  if (!stream) return;

  if (!frozen) {
    // Apply filters and draw video to offscreen
    offscreenCtx.filter = `brightness(${brightness}%) contrast(${contrast}%) saturate(${saturation}%)`;
    // Center crop
    const sx = (video.videoWidth - canvas.width) / 2;
    const sy = (video.videoHeight - canvas.height) / 2;
    offscreenCtx.drawImage(video, sx, sy, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);
  }

  if (autoGrid) {
    handleAutoGrid();
  }

  if (currentQuadrantEffect) {
    renderKaleidoscope();
  } else {
    ctx.drawImage(offscreenCanvas, 0, 0);
  }

  requestAnimationFrame(loop);
}

function handleAutoGrid() {
  const now = Date.now();
  if (now - lastAutoUpdate < 150) return; 

  const data = offscreenCtx.getImageData(0, 0, canvas.width, canvas.height).data;
  let sum = 0;
  for (let i = 0; i < data.length; i += 100) {
    sum += (0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2]);
  }
  const avg = sum / (data.length / 100);
  const newSize = Math.max(1, Math.min(40, Math.round((avg / 255) * 40)));
  
  if (Math.abs(newSize - gridSize) > 2) {
    gridSize = newSize;
    updateGridDisplay();
  }
  lastAutoUpdate = now;
}

function renderKaleidoscope() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.imageSmoothingEnabled = false;

  const step = canvas.width / gridSize;
  const half = step / 2;

  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize; c++) {
      const centerX = c * step + half;
      const centerY = r * step + half;

      // Source "Quadrant" selection based on target effect
      let sx = c * step;
      let sy = r * step;
      if (currentQuadrantEffect === 'A2') sx += half;
      if (currentQuadrantEffect === 'B1') sy += half;
      if (currentQuadrantEffect === 'B2') { sx += half; sy += half; }

      // Draw mirrored quadrants
      [
        { x: 1, y: 1 },  { x: -1, y: 1 },
        { x: 1, y: -1 }, { x: -1, y: -1 }
      ].forEach(t => {
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.scale(t.x, t.y);
        ctx.drawImage(offscreenCanvas, sx, sy, half, half, 0, 0, half, half);
        ctx.restore();
      });
    }
  }
}

/* ---------- DOWNLOAD ---------- */

document.getElementById('downloadButton').onclick = () => {
  const a = document.createElement('a');
  a.download = 'processor_export.png';
  a.href = canvas.toDataURL();
  a.click();
};

setEffect('A1');
updateGridDisplay();
</script>

</body>
</html>
