<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Catoptric</title>

<style>
/* --- BASE STYLES --- */
body {
  margin: 0;
  background: #111;
  color: #eee;
  font-family: sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
}

#app {
  width: 100%;
  display: flex;
  flex-direction: column;
}

canvas {
  width: 100%;
  aspect-ratio: 1 / 1;
  background: #000;
  display: block;
}

#controls {
  width: 100%;
  background: #1a1a1a;
  padding: 1rem;
  display: grid;
  grid-template-columns: repeat(4, 1fr); 
  gap: 0.6rem;
  box-sizing: border-box;
}

/* MOBILE SIZES (Below 1050px) */
.button {
  background: #333;
  border: 1px solid #444;
  color: #fff;
  padding: 0.8rem 0.2rem;
  border-radius: 6px;
  font-size: 1.5rem; 
  cursor: pointer;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
}

.slider-wrap {
  grid-column: span 4;
  display: flex;
  flex-direction: column;
  gap: 0.3rem;
  font-size: 1.5rem; 
  background: #222;
  padding: 10px;
  border-radius: 4px;
}

/* DESKTOP ADAPTATION (1050px+) */
@media (min-width: 1050px) {
  body { justify-content: center; padding: 20px; }
  #app { max-width: 1100px; flex-direction: row; align-items: flex-start; gap: 20px; }
  canvas { width: 550px; position: sticky; top: 20px; border-radius: 8px; }
  #controls { flex: 1; border-radius: 8px; grid-template-columns: repeat(4, 1fr); }
  .button { font-size: 0.85rem; }
  .slider-wrap { font-size: 0.75rem; }
}

/* MODAL STYLES */
#infoModal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0; top: 0; width: 100%; height: 100%;
  background-color: rgba(0,0,0,0.85);
  overflow-y: auto;
}
.modal-content {
  background-color: #222;
  margin: 10% auto;
  padding: 20px;
  border: 1px solid #444;
  width: 85%;
  max-width: 600px;
  border-radius: 12px;
  line-height: 1.6;
}
.close-modal {
  background: #007bff;
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
  float: right;
  cursor: pointer;
  font-weight: bold;
}

/* UTILS */
.button:active { background: #444; }
.button.active-effect { background: #007bff; border-color: #00a2ff; }
.effect-button { grid-column: span 1; }
.slider-header { display: flex; justify-content: space-between; color: #aaa; }
input[type="range"] { width: 100%; cursor: pointer; }
#startWebcamButton.full-width { grid-column: span 2; }
.span-1 { grid-column: span 1; }
.span-2 { grid-column: span 2; }
.span-4 { grid-column: span 4; }

#gridSizeDisplay {
  grid-column: span 4;
  text-align: center;
  font-family: monospace;
  background: #000;
  padding: 0.5rem;
  border-radius: 4px;
  color: #00ffcc;
  font-weight: bold;
}

#videoFeed { display: none; }
</style>
</head>

<body>

<div id="infoModal">
  <div class="modal-content">
    <button class="close-modal" onclick="closeModal()">Close</button>
    <h2 style="color:#00ffcc">How to Use</h2>
    <p><strong>Start:</strong> Tap Start to activate your camera.</p>
    <p><strong>Switch:</strong> If your device has multiple cameras (like front and back), use Switch to cycle through them.</p>
    <p><strong>Freeze:</strong> Use Freeze/Unfreeze to lock a specific frame and continue applying effects to that static image.</p>
    <p><strong>Grid Density:</strong> Slide to change the complexity.</p>
    <p><strong>Auto Mode:</strong> Tick Auto to let the processor dynamically adjust the grid based on the brightness and movement in your scene.</p>
    <p>Fine-tune your visual using the <strong>Brightness, Contrast, and Saturation</strong> sliders. These adjustments happen in real-time.</p>
    <p>Choose from four distinct mathematical mirroring modes: <strong>Agnes & Bridget & Chuck & Donald</strong> (named after modernist artists).</p>
    <p><strong>Original:</strong> View the processed feed without the kaleidoscope grid.</p>
    <p><strong>Download:</strong> Hit the green button to save your current view as a high-resolution PNG file.</p>
    <hr style="border:0; border-top:1px solid #444">
    <p style="font-style: italic; color: #aaa;">For best results, try a selfie with most of your head filling the frame, straight on, with a plain background. I think the default 10x10 grid is best.</p>
  </div>
</div>

<div id="app">
  <canvas id="canvas"></canvas>

  <div id="controls">
    <div id="gridSizeDisplay">GRID: 10×10</div>

    <button id="startWebcamButton" class="button span-1">Start</button>
    <button id="switchCameraButton" class="button span-1" style="display: none;">Switch</button>
    <button id="freezeButton" class="button span-2">Freeze/Unfreeze</button>
    
    <button id="infoBtn" class="button span-2" style="background: #444; font-weight: bold;">Info</button>
    <label class="button span-2">
      <input id="autoGridToggle" type="checkbox" style="margin-right: 8px; transform: scale(1.5);"> Auto
    </label>

    <div class="slider-wrap">
      <div class="slider-header"><span>Grid Density</span><span id="val-grid">10</span></div>
      <input id="gridSlider" type="range" min="1" max="30" value="10">
    </div>

    <div class="slider-wrap">
      <div class="slider-header"><span>Brightness</span><span id="val-bright">100%</span></div>
      <input id="brightnessSlider" type="range" min="50" max="150" value="100">
    </div>

    <div class="slider-wrap">
      <div class="slider-header"><span>Contrast</span><span id="val-contrast">100%</span></div>
      <input id="contrastSlider" type="range" min="50" max="150" value="100">
    </div>

    <div class="slider-wrap">
      <div class="slider-header"><span>Saturation</span><span id="val-sat">100%</span></div>
      <input id="saturationSlider" type="range" min="0" max="200" value="100">
    </div>

    <button id="effectA1" class="button effect-button">Agnes</button>
    <button id="effectA2" class="button effect-button">Bridget</button>
    <button id="effectB1" class="button effect-button">Chuck</button>
    <button id="effectB2" class="button effect-button">Donald</button>

    <button id="clearEffectButton" class="button span-2">Original</button>
    <button id="downloadButton" class="button span-2" style="background:#28a745; border-color: #1e7e34;">Download</button>
  </div>
</div>

<video id="videoFeed" playsinline autoplay muted></video>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const video = document.getElementById('videoFeed');
const offscreenCanvas = document.createElement('canvas');
const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });

let stream = null, frozen = false, gridSize = 10, autoGrid = false;
let currentEffect = 'A1', brightness = 100, contrast = 100, saturation = 100;
let lastAutoUpdate = 0, currentFacingMode = 'user';

/* --- Modal Logic --- */
const modal = document.getElementById("infoModal");
document.getElementById("infoBtn").onclick = () => modal.style.display = "block";
function closeModal() { modal.style.display = "none"; }
window.onclick = (event) => { if (event.target == modal) closeModal(); }

const updateVal = (id, val) => document.getElementById(id).textContent = val;

document.getElementById('gridSlider').oninput = (e) => {
  if (!autoGrid) {
    gridSize = parseInt(e.target.value);
    updateVal('val-grid', gridSize);
    document.getElementById('gridSizeDisplay').textContent = `GRID: ${gridSize}×${gridSize}`;
  }
};

document.getElementById('brightnessSlider').oninput = (e) => { brightness = e.target.value; updateVal('val-bright', brightness + '%'); };
document.getElementById('contrastSlider').oninput = (e) => { contrast = e.target.value; updateVal('val-contrast', contrast + '%'); };
document.getElementById('saturationSlider').oninput = (e) => { saturation = e.target.value; updateVal('val-sat', saturation + '%'); };
document.getElementById('autoGridToggle').onchange = (e) => autoGrid = e.target.checked;

function setEffect(e) {
  currentEffect = e;
  document.querySelectorAll('.effect-button').forEach(b => b.classList.toggle('active-effect', b.id === `effect${e}`));
}

['A1','A2','B1','B2'].forEach(e => document.getElementById(`effect${e}`).onclick = () => setEffect(e));
document.getElementById('clearEffectButton').onclick = () => setEffect(null);

async function checkCameraCount() {
  const devices = await navigator.mediaDevices.enumerateDevices();
  const videoDevices = devices.filter(device => device.kind === 'videoinput');
  const switchBtn = document.getElementById('switchCameraButton');
  const startBtn = document.getElementById('startWebcamButton');
  if (videoDevices.length > 1) {
    switchBtn.style.display = 'flex';
    startBtn.classList.remove('full-width');
  } else {
    switchBtn.style.display = 'none';
    startBtn.classList.add('full-width');
  }
}

async function startCamera() {
  if (stream) stream.getTracks().forEach(track => track.stop());
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: currentFacingMode } });
    video.srcObject = stream;
    await video.play();
    const size = Math.floor(Math.min(video.videoWidth, video.videoHeight));
    canvas.width = canvas.height = size;
    offscreenCanvas.width = offscreenCanvas.height = size;
    loop();
  } catch (err) { alert("Camera error."); }
}

document.getElementById('startWebcamButton').onclick = startCamera;
document.getElementById('switchCameraButton').onclick = () => {
  currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
  startCamera();
};
document.getElementById('freezeButton').onclick = () => {
  frozen = !frozen;
  document.getElementById('freezeButton').classList.toggle('active-effect', frozen);
};

function loop() {
  if (!stream) return;
  if (!frozen) {
    offscreenCtx.filter = `brightness(${brightness}%) contrast(${contrast}%) saturate(${saturation}%)`;
    const sx = Math.floor((video.videoWidth - canvas.width) / 2);
    const sy = Math.floor((video.videoHeight - canvas.height) / 2);
    offscreenCtx.drawImage(video, sx, sy, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);
  }
  if (autoGrid) handleAutoGrid();
  
  if (currentEffect) {
    renderKaleidoscope();
  } else {
    ctx.drawImage(offscreenCanvas, 0, 0);
  }
  
  requestAnimationFrame(loop);
}

function handleAutoGrid() {
  const now = Date.now();
  if (now - lastAutoUpdate < 150) return;
  const data = offscreenCtx.getImageData(0, 0, canvas.width, canvas.height).data;
  let sum = 0;
  for (let i = 0; i < data.length; i += 120) sum += (0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2]);
  const avg = sum / (data.length / 120);
  const newSize = Math.max(1, Math.min(30, Math.round((avg / 255) * 30)));
  if (Math.abs(newSize - gridSize) > 2) {
    gridSize = newSize;
    updateVal('val-grid', gridSize);
    document.getElementById('gridSizeDisplay').textContent = `GRID: ${gridSize}×${gridSize}`;
    document.getElementById('gridSlider').value = gridSize;
  }
  lastAutoUpdate = now;
}

function renderKaleidoscope() {
  // 1. Calculate grid dimensions
  const step = Math.floor(canvas.width / gridSize); // Size of the full cell
  const qSize = step / 2; // Size of one quadrant (25% area)
  
  // We draw slightly larger (+0.5) to prevent black hairlines between quadrants
  const dSize = qSize + 0.5; 

  // 2. Define Mirroring Configurations (Scale X, Scale Y)
  // [TL, TR, BL, BR] -> [A1, A2, B1, B2]
  let scales = [];

  switch (currentEffect) {
    case 'A1': // AGNES: A1 (TL) is Original
      scales = [
        [1, 1],   // TL (Original)
        [-1, 1],  // TR (Mirrored Horz)
        [1, -1],  // BL (Mirrored Vert)
        [-1, -1]  // BR (Mirrored H+V)
      ];
      break;
    case 'B1': // BRIDGET: B1 (BL) is Original
      scales = [
        [1, -1],  // TL (Mirrored Vert from BL)
        [-1, -1], // TR (Mirrored H+V from BL)
        [1, 1],   // BL (Original)
        [-1, 1]   // BR (Mirrored Horz from BL)
      ];
      break;
    case 'A2': // CHUCK: A2 (TR) is Original
      scales = [
        [-1, 1],  // TL (Mirrored Horz from TR)
        [1, 1],   // TR (Original)
        [-1, -1], // BL (Mirrored H+V from TR)
        [1, -1]   // BR (Mirrored Vert from TR)
      ];
      break;
    case 'B2': // DONALD: B2 (BR) is Original
      scales = [
        [-1, -1], // TL (Mirrored H+V from BR)
        [1, -1],  // TR (Mirrored Vert from BR)
        [-1, 1],  // BL (Mirrored Horz from BR)
        [1, 1]    // BR (Original)
      ];
      break;
    default:
      ctx.drawImage(offscreenCanvas, 0, 0, canvas.width, canvas.height);
      return;
  }

  // 3. Render Loop
  for (let r = 0; r < gridSize; r++) {
    const sy = r * step; // Source Y (Full cell top)
    const dy = r * step; // Dest Y (Full cell top)

    for (let c = 0; c < gridSize; c++) {
      const sx = c * step; // Source X (Full cell left)
      const dx = c * step; // Dest X (Full cell left)

      // Calculate centers of the 4 quadrants for this cell
      // We translate to the center of the quadrant -> scale -> draw -> restore
      
      // Quadrant 1: Top-Left (A1)
      ctx.save();
      ctx.translate(dx + qSize/2, dy + qSize/2);
      ctx.scale(scales[0][0], scales[0][1]);
      ctx.drawImage(offscreenCanvas, sx, sy, step, step, -qSize/2, -qSize/2, dSize, dSize);
      ctx.restore();

      // Quadrant 2: Top-Right (A2)
      ctx.save();
      ctx.translate(dx + qSize*1.5, dy + qSize/2);
      ctx.scale(scales[1][0], scales[1][1]);
      ctx.drawImage(offscreenCanvas, sx, sy, step, step, -qSize/2, -qSize/2, dSize, dSize);
      ctx.restore();

      // Quadrant 3: Bottom-Left (B1)
      ctx.save();
      ctx.translate(dx + qSize/2, dy + qSize*1.5);
      ctx.scale(scales[2][0], scales[2][1]);
      ctx.drawImage(offscreenCanvas, sx, sy, step, step, -qSize/2, -qSize/2, dSize, dSize);
      ctx.restore();

      // Quadrant 4: Bottom-Right (B2)
      ctx.save();
      ctx.translate(dx + qSize*1.5, dy + qSize*1.5);
      ctx.scale(scales[3][0], scales[3][1]);
      ctx.drawImage(offscreenCanvas, sx, sy, step, step, -qSize/2, -qSize/2, dSize, dSize);
      ctx.restore();
    }
  }
}

document.getElementById('downloadButton').onclick = () => {
  const a = document.createElement('a');
  a.download = `LeeCampbellCatoptric2026.png`;
  a.href = canvas.toDataURL();
  a.click();
};

checkCameraCount();
setEffect('A1');
</script>
</body>
</html>


